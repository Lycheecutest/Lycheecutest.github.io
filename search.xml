<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis-Learning</title>
      <link href="/2022/04/22/Redis-Learning/"/>
      <url>/2022/04/22/Redis-Learning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>规范数据库设计</title>
      <link href="/2022/04/22/%E8%A7%84%E8%8C%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/04/22/%E8%A7%84%E8%8C%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h5 id="良好的数据库设计"><a href="#良好的数据库设计" class="headerlink" title="良好的数据库设计"></a>良好的数据库设计</h5><ul><li>节省内存空间</li><li>保证数据库的完整性</li><li>方便开发系统</li></ul><h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><ul><li>分析需求：分析业务和需要处理的数据库的需求</li><li>概要设计：设计关系图E-R图</li></ul><h5 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h5><ul><li>信息重复</li><li>更新异常</li><li>插入异常<ul><li>无法正常显示信息</li></ul></li><li>删除异常<ul><li>丢失有效信息</li></ul></li></ul><h6 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h6><p>原子项：要求数据库表的每一列都是不可分割的原子数据项</p><h6 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h6><p>满足第一范式</p><p>非码属性必须完全依赖于候选码。保证每张表只描述一件事情</p><h6 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h6><p>满足第一范式、第二范式</p><p>保证数据表中的每一列数据都和主键直接相关，而不能间接相关</p><h5 id="规范性和性能的问题"><a href="#规范性和性能的问题" class="headerlink" title="规范性和性能的问题"></a>规范性和性能的问题</h5><p>性能问题: 关联查询的表不得超过三张表</p><p>数据库性能更加重要</p><p>可以考虑故意增加冗余字段，从多表查询变为单表查询</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发</title>
      <link href="/2022/04/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2022/04/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/Lycheecutest/raw/imgs/blog/202204130913457.png" alt="image-20220413091254286"></p><p>软件项目计划书</p><p>项目进度报告</p><p>项目开发总结报告</p><p>需求规格说明书</p><p>程序概要设计说明书</p><p>详细设计说明书</p><p>测试计划</p><p>软件测试分析报告</p><p>用户操作手册</p><p>演示文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql Learning</title>
      <link href="/2022/04/03/MySql-Learning/"/>
      <url>/2022/04/03/MySql-Learning/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h3><p>DB： database 数据库 存储数据的“仓库”。 保存一系列有组织的数据。</p><p>DBMS： 数据库管理系统 database Management System。 数据库是通过DBMS创建和操作的容易。常见的DBMS MySql、Oracle、SQL Server</p><p>SQL：结构化查询语言。</p><h3 id="Mysql命令行常见命令"><a href="#Mysql命令行常见命令" class="headerlink" title="Mysql命令行常见命令"></a>Mysql命令行常见命令</h3><p>首先命令行 mysql -uroot -proot 进入Mysql服务端</p><ol><li>show databases;     显示所有数据库</li><li>use 库名；                使用某个数据库</li><li>show tables;             显示该数据库的所有表</li><li>show tables from 库名;  显示某个数据库的表</li><li>select database（）;      查看当前所在库</li><li>create table 表名(列名 属性，列名 属性， ……..);</li><li>desc(DESCRIBE) 表名;                   显示表的结构</li><li>在命令行中能正常使用Sql语句操作数据库</li></ol><p><strong>Tips</strong>：</p><ol><li>所有语句后面需要增加分号</li></ol><h3 id="Mysql语法规范"><a href="#Mysql语法规范" class="headerlink" title="Mysql语法规范"></a>Mysql语法规范</h3><ol><li>不区分大小写，规范： 建议关键字大写，表名、列名小写；</li><li>每条命令根据需要可以进行缩进、换行；</li><li>注释<ol><li>单行注释  #注释文字、–注释文字</li><li>多行注释   &#x2F;*多行注释文字*&#x2F;</li></ol></li><li>为了提高可读性、各子句分行写</li><li>字符串类型和日期时间类型数据可以使用单引号表示</li><li>数据库、表名不得超过30个字符，变量名为29个</li><li>必须只能包含A-Z、a-z、0-9、_共63个字符</li><li>数据库名、表名、字段名等对象名不能包含空格</li></ol><h3 id="Sql语言学习"><a href="#Sql语言学习" class="headerlink" title="Sql语言学习"></a>Sql语言学习</h3><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>数据定义语言</p><p>CREATE、ALTER、DROP、RENAME、TRUCATE</p><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>数据操作语言</p><p>INSERT、DELETE、UDPDATE、SELECT</p><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><ol><li><p>SELECT 字段名 FROM 表名   * 是所有的列 (查询所有字段写出所有字段名，使用*效率低)</p></li><li><p>SELECT 字段名 AS&#x2F;空格&#x2F;使用双引号 别名 FROM 表名（给查询结果的列名起别名）   </p></li><li><p>SELECT &#x3D;&#x3D;<strong>DISTINCT</strong>&#x3D;&#x3D; 字段名 FROM 表名     加上该字段去重</p></li><li><p>空值（NULL）参与运算，结果一定是NULL    IFNULL(字段名,0)</p></li><li><p>如果表名跟关键字重名，  &#96;&#96; &lt;–使用着重号</p></li><li><p>查询常数，你在查询语句中，直接使用某个常数，会给所有结果设置一个常数列，比如SELECT ‘com.hnust’ name FROM student，所有结果会出现一列 列名叫com.hnust 属性是com.hnust</p></li><li><p>&#x3D;&#x3D;无法修改数据库&#x3D;&#x3D;</p></li><li><p>Select语句的模板</p></li></ol><p>​    SELECT 。。。FROM 。。。WHERE 。。。GROUP BY 。。。ORDER BY 。。。</p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ol><li><p>+、-、*、&#x2F;、都是正常运算，%取模运算</p></li><li><p>比较运算符：</p><p>比较结果为真则返回1，比较的结果为假则返回0，其他情况返回NULL   </p><ol><li>&#x3D;、&lt;&gt;(!&#x3D;)、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&lt;&#x3D;&gt;（安全等于） </li><li>一边是数值，一边是字符串。字符串存在隐式转换，如果不能转换为数值，就为0</li><li>如果两边都是字符串，就会按照字符串比较，就是逐个比较字符的ASCII码</li><li>使用安全等于，可以让NULL参与比较（可以正常比较，两边都是NULL返回1，不然返回0</li></ol></li><li><p>其他运算符</p></li><li><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/202204061036074.jfif" alt="运算符"></p></li><li><p>and 和 or 同时出现，and优先级比or高，会先执行and。</p></li><li><p>in包含，相当于多个or。（not in &#x3D;&gt; 不在这个范围中） in后面接具体的信息的值，比如年龄(20,21,22)。</p></li><li><p>like 模糊查询。（% 匹配任意多个字符，可以是0个，  _ 任意一个字符，必须占一位）</p></li></ol><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><ol><li>order by 列名（根据该列的值进行排序，默认升序 ASC, 降序 DESC）</li><li>order by 列名 排序方式 ， 列名 排序方式（先根据第一个的值排序，如果第一列有相同值，再按照第二列的值进行排序）</li></ol><h5 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h5><table><thead><tr><th align="center">str_to_date</th><th align="center">将字符串转换成日期</th></tr></thead><tbody><tr><td align="center">date_format</td><td align="center">格式化日期</td></tr><tr><td align="center">format</td><td align="center">设置千分位</td></tr><tr><td align="center">round(数值，保留小数位)</td><td align="center">四舍五入</td></tr><tr><td align="center">rand()</td><td align="center">生成随机数</td></tr><tr><td align="center">ifnull</td><td align="center">可以将Null转换成一个具体值</td></tr><tr><td align="center">Lower  Upper</td><td align="center">转换大小写</td></tr><tr><td align="center">Substr</td><td align="center">取子串（被裁剪的字符串，起始下标【从1开始】，截取的长度）</td></tr><tr><td align="center">Length</td><td align="center">取长度</td></tr><tr><td align="center">trim</td><td align="center">去空格</td></tr><tr><td align="center">case..when..then..when..then..else..end</td><td align="center"></td></tr></tbody></table><h5 id="分组函数（多行处理函数）"><a href="#分组函数（多行处理函数）" class="headerlink" title="分组函数（多行处理函数）"></a>分组函数（多行处理函数）</h5><table><thead><tr><th align="center">函数名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">计数</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr><tr><td align="center">avg</td><td align="center">平均</td></tr><tr><td align="center">max、min</td><td align="center">最值</td></tr></tbody></table><ol><li>分组函数自动过滤Null值</li><li>Count（*）和 Count(具体列)区别<ol><li>Count(字段名) 统计该字段下所有不为NUll的元素的总数</li><li>Count（*）统计数据表中的行数</li></ol></li><li>分组函数不能直接使用在Where子句中</li></ol><h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>数据控制语言</p><p>COMMIT、ROLLBACK、SAVEPOINT、GRANT、REVOKE</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2022/03/15/Java%E9%9B%86%E5%90%88/"/>
      <url>/2022/03/15/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>arrayList集合的长度是可以随意变化的</p><p>对于Array List来说，有一个&lt; E &gt;代表泛型</p><p>泛型：也就是装在集合当中的所有元素，全都是统一的数据类型。<strong>泛型只能是引用类型，不能是基本类型.</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean add(E e)   public E get(int index)      返回值是对应索引的元素   public E remove(int index)   返回值就是被删除的元素   public int size()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h4><p>public static String toString ( 数组 ) </p><p>将参数数组编程字符串，按默认格式</p><p>public static void sort ( 数组 )</p><p>将数组按默认升序（从小到大）进行排序</p><p>Tips:</p><ol><li>如果是数值，sort默认按照升序从小到大</li><li>如果是字符串，sort默认按照字母升序</li><li>如果是自定义类型，那么这个自定义类型的类需要有Comparable或者Comparator接口的支持</li></ol><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol><li><p>字符串的内容永不可变</p></li><li><p>字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[ ]字节数组</p></li><li><p>对于引用类型来说  &#x3D;&#x3D;是比较【地址值】</p></li><li><p>字符串的内容比较</p><ol><li>public boolean equals(Object obj) 相同返回true</li><li>public boolean equalsIgnoreCase(Object obj) 忽略大小写比较内容</li></ol></li><li><p>字符串常用方法</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int length()                字符串长度public String concat(String str)   将当前字符串和参数字符串拼接成为新的字符串public char charAt(int index)      获取指定索引位置的单个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String( ) 创建一个空白字符串，不含有任何内容public String(byte[] array &#x2F; char[] array） 根据数组的内容，来创建对应的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串的截取方法"><a href="#字符串的截取方法" class="headerlink" title="字符串的截取方法"></a>字符串的截取方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String substring(int index)截取从参数位置一直到字符串末尾，返回新字符串public String substring(int begin, int end)截取指定范围内的字符串 左闭右开区间  [begin，end)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串的转换方法"><a href="#字符串的转换方法" class="headerlink" title="字符串的转换方法"></a>字符串的转换方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public char[] toCharArray()  将当前字符串拆分成字符数组作为返回值    public byte[] getBytes()     将当前字符串拆分成字节数组作为返回值    public String replace(oldString, newString) 将所有出现的老字符串替换成为新的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串的分割方法"><a href="#字符串的分割方法" class="headerlink" title="字符串的分割方法"></a>字符串的分割方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String[] split(String regex) 按照参数的规则，将字符串切分成为若干部分该方法参数是一个正则表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>进行字符串的相加，内存中会有多个字符串，占用空间多，效率低下</p><p>使用StringBuilder字符串缓冲区，可以提高字符串的操作效率（看成一个可变长的字符串</p><p>底层也是一个数组，没有被final修饰</p><p>public StringBuilder append（）方法</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>是Vector的子类，实现了标准的后进先出的栈。</p><p><code>boolean empty()</code> 测试堆栈是否为空</p><p><code>Object peek()</code> 查看堆栈顶部的对象，但不从中移除它们</p><p><code>Object pop()</code> 移除堆栈顶部的对象，并依次作为返回值</p><p><code>Object push(Object element)</code> 把值压入堆栈顶部</p><p><code>int serach(Object element)</code> 返回对象再堆栈中的位置</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>双端队列                         <a href="https://www.cainiaojc.com/java/java-arraydeque.html">Java ArrayDeque - Java教程 </a></p><ul><li>add() - 将指定的元素插入ArrayDeque双端队列的末尾</li><li>addFirst() -在ArrayDeque双端队列的开头，插入指定的元素</li><li>addLast() - 在ArrayDeque双端队列的末尾插入指定的内容（等效于add()）</li></ul><p><strong>注意：</strong>如果ArrayDeque双端队列已满，则所有这些方法add()，addFirst()和addLast()都会引发IllegalStateException。</p><ul><li>offer() - 将指定的元素插入ArrayDeque双端队列的末尾</li><li>offerFirst() - 在ArrayDeque双端队列的开始处插入指定的元素</li><li>offerLast() - 将指定的元素插入ArrayDeque双端队列的末尾</li></ul><p><strong>注意：</strong> offer()，offerFirst()并offerLast()返回true是否成功插入元素；否则，返回。如果ArrayDeque双端队列已满，则这些方法返回false。</p><ul><li>getFirst() - 返回ArrayDeque双端队列的第一个元素</li><li>getLast() - 返回ArrayDeque双端队列的最后一个元素</li></ul><p><strong>注：</strong>如果ArrayDeque双端队列为空，getFirst()和getLast()抛出NoSuchElementException。</p><ul><li><p>peek() - 返回ArrayDeque双端队列的第一个元素</p></li><li><p>peekFirst() - 返回ArrayDeque双端队列的第一个元素（等效于peek()）</p></li><li><p>peekLast() - 返回ArrayDeque双端队列的最后一个元素</p></li><li><p>remove() - 返回并从ArrayDeque双端队列的第一个元素中删除一个元素</p></li><li><p>remove(element) - 返回并从ArrayDeque双端队列的头部删除指定的元素</p></li><li><p>removeFirst() - 返回并从ArrayDeque双端队列中删除第一个元素（等效于remove()）</p></li><li><p>removeLast() - 返回并从ArrayDeque双端队列中删除最后一个元素</p></li></ul><p><strong>注意：</strong>如果数组双端队列为空，则remove()，removeFirst()和removeLast()方法将引发异常。 另外，如果找不到元素，则remove(element)会引发异常。</p><ul><li>poll() - 返回并删除ArrayDeque双端队列的第一个元素</li><li>pollFirst() - 返回并删除ArrayDeque双端队列的第一个元素（等效于poll()）</li><li>pollLast() - 返回并删除ArrayDeque双端队列的最后一个元素</li></ul><p><strong>注意：</strong>如果ArrayDeque双端队列为空，则如果找不到该元素，则poll()，pollFirst()和pollLast()返回null。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/2022/03/15/Java%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/15/Java%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>特点：</p><ol><li>是一种引用数据类型</li><li>数组当中的多个数据，类型必须统一</li><li>数组的长度在程序运行期间不可改变</li></ol><p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值</p><p>两种常见的初始化方式：</p><ol><li><p>动态初始化（指定数组的长度、没有赋值前，数组的所有内容都是类型对应的默认值</p><p>整数类型：  0</p><p>浮点类型： 0.0</p><p>字符类型： ‘\u0000’</p><p>布尔类型： false</p><p>引用类型： null</p></li></ol><p>数据类型[ ] 数组名称 &#x3D; new 数据类型[数组长度]；</p><ol start="2"><li>静态初始化（指定数组的内容 、静态初始化也有赋默认值的过程，不过马上替换我们输入的值</li></ol><p>数据类型[ ] 数组名称 &#x3D; new 数据类型[ ]{数组内容}；</p><p>简略静态初始化: 数据类型[ ] 数组名称 &#x3D; {数组内容}；</p><p>数组长度：  数组名称.length 返回数组长度 int类型</p><p>Tips:</p><ol><li>直接打印数组名称，输出的是数组对应的内存地址哈希值，就是数组首地址</li><li>ArrayIndexOutOfBoundsException   数组索引越界异常</li><li>NullPointerException  空指针异常</li></ol><p>Java的内存划分为五个部分：</p><ol><li>栈：存放的是方法中的局部变量<ol><li>方法的参数，或者是方法内部的变量</li><li>一旦超出作用域，立刻从栈内存中消失</li></ol></li><li>堆：所有new出来的对象，都在堆当中<ol><li>堆内存里面只有一个地址值：16进制</li><li>堆内存中的数据都有默认值</li></ol></li><li>方法区：存放class相关信息，包括方法信息</li><li>本地方法栈：与操作系统相关</li><li>寄存器：与CPU相关</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus笔记</title>
      <link href="/2022/03/04/MybatisPlus%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/04/MybatisPlus%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前提：使用IDEA + Maven + Spring（Spring Boot）</p><p>导入依赖：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">数据库驱动&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&#x2F;**Lombok**&#x2F;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.0.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h4><p>使用MybatisPlus，所有的Sql语句是不可见的，想要看到Sql语句，必须配置日志。</p><p>配置日志：在application.yml文件中</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">mybatis-plus:   configuration:  log-impl: org.apache.ibatis.logging.stdout.StdOutImpl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h4><p>基本的CRUD使用就是使用创建的Mapper对象，调用对应的方法即可</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>数据库插入的id的默认值为：全局的默认唯一值</p><p>主键生成策略： 雪花算法</p><pre class="line-numbers language-java@TableId" data-language="java@TableId"><code class="language-java@TableId">@TableId()&#x2F;**ID_WORKER  全局唯一id  默认值**&#x2F;IdType&#123;AUTP(0),    &#x2F;&#x2F;数据库id自增NONE(1),    &#x2F;&#x2F; 未设置INPUT(2),   &#x2F;&#x2F; 手动输入ID_WORKER(3),&#x2F;&#x2F;默认的全局唯一idUUID(4),     &#x2F;&#x2F;全局唯一id uuidID_WORKER_STR(5); &#x2F;&#x2F;ID_WORKER 字符串表示法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>主键自增：</strong></p></blockquote><p>配置主键自增：</p><ol><li>实体类字段上 @TableId(type &#x3D; IdType.AUTO)</li><li><strong>数据库字段一定要是自增！</strong></li></ol><h5 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h5><h6 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;列名&quot;,&quot;条件值&quot;)**Mapper.selectByMap(map);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;分页插件 首先在自己的MybatisPlusConfig中配置分页对象@Beanpublic PaginationInterceptor paginationInterceptor()&#123;    return new PaginationInterceptor();&#125;&#x2F;&#x2F;测试Page&lt;&gt; page &#x3D; new Page&lt;&gt;(count: ,size: );Mapper.selectPage(page,null);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>Mapper.updateById(参数是数据对象、不止是Id)</p><p>所有Sql都是自动动态配置</p><h6 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h6><p>创建时间、修改时间！这些个操作一般都是自动化完成的，不希望手动更新</p><p>方式一：数据库级别（工作中不允许修改数据库）</p><ol><li>在表中新增字段 <code>create_time</code> 、<code>updatetime</code> </li><li>再次测试，实体类同步属性</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Date createTime;private Date updateTime;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Ps:</strong> </p><ol><li><p>默认值：CURRENT_TIMESTAMP</p></li><li><p>更新操作，勾选更新</p></li></ol><p>方式二：代码级别</p><ol><li>删除数据库的默认值、更新操作</li><li>实体类字段属性上需要增加注解</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@TableField(fill &#x3D; FieldFill.INSERT)  创建时间  private Date createTime;@TableField(fill &#x3D; FieldFill.INSERT_UPDATE)  更新时间  private Date updateTime;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>编写处理器</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        log.info(&quot;start insert fill ....&quot;);        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#x2F;&#x2F; 起始版本 3.3.0(推荐使用)        &#x2F;&#x2F; 或者        this.strictInsertFill(metaObject, &quot;createTime&quot;, () -&gt; LocalDateTime.now(), LocalDateTime.class); &#x2F;&#x2F; 起始版本 3.3.3(推荐)    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        log.info(&quot;start update fill ....&quot;);        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#x2F;&#x2F; 起始版本 3.3.0(推荐)        &#x2F;&#x2F; 或者        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, () -&gt; LocalDateTime.now(), LocalDateTime.class); &#x2F;&#x2F; 起始版本 3.3.3(推荐)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">QuerWrapper&lt;&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();调用wrapper的方法添加条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><blockquote><p>总是认为不会出现问题，无论做什么操作都不会自动上锁。如果出现了问题，再次更新值测试。</p><blockquote><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li><li>如果 version 不对，就更新失败</li></ul></blockquote></blockquote><ol><li>数据库和实体类添加Version字段</li><li>实体类字段添加@version注解</li><li>增加一个<code>Mybatisplus</code>配置类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123;    MybatisPlusInterceptor interceptor &#x3D; new        MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());    return interceptor;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><blockquote><p>物理删除：直接从数据库中直接移除，删除所有的数据</p><p>逻辑删除：在数据库中没有被删除，通过一个变量让他失效，deleted</p></blockquote><ol><li>在数据表中增加一个deleted字段</li><li>在实体类中同步对应属性并添加注解</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@TableLogicprivate Integer deleted;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>配置</li></ol><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">mybatis-plus:global-config:db-config:logic-delete-value&#x3D;1logic-not-delete-value&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>使用，Mybatisplus会自动拼接查询条件delete &#x3D; 0</li></ol><h4 id="代码自动生成器"><a href="#代码自动生成器" class="headerlink" title="代码自动生成器"></a>代码自动生成器</h4><p>dao、pojo、service、controller自动生成</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">引入依赖    这是新版本 3.5.1以上的mybatis-plus才支持&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.5.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mybatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣</title>
      <link href="/2022/03/03/%E5%8A%9B%E6%89%A3/"/>
      <url>/2022/03/03/%E5%8A%9B%E6%89%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="判断字符串是否唯一"><a href="#判断字符串是否唯一" class="headerlink" title="判断字符串是否唯一"></a>判断字符串是否唯一</h3><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p><p>限制：</p><ul><li>0 &lt;&#x3D; len &lt;&#x3D; 100</li><li>可以考虑不使用额外的数据结构</li></ul><ol><li>使用双重循环</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isUnique(String astr) &#123;    if(astr.length() &gt; 26) return false;        for(int i &#x3D; 0; i &lt; astr.length(); i++)&#123;        for(int j &#x3D; i + 1; j &lt; astr.length(); j++)&#123;            if(asrt.charAt(i) &#x3D;&#x3D; astr.charAt(j)) return false;        &#125;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ol start="2"><li>用数组记录出现过的字符</li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">    public boolean isUnique(String astr) &#123;        astr.toLowerCase();        int[] str &#x3D; new int[28];        for (int i &#x3D; 0; i&lt; astr.length(); i++)&#123;            int var &#x3D; astr.charAt(i) -&#39;a&#39;;            if(str[var] &#x3D;&#x3D; 0) str[var] &#x3D; 1;            else return false;        &#125;        return true;    &#125;&#x2F;** 使用了toLowerCase()后，字符全部变成小写，使用后无法获得原字符串**&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ol start="3"><li>使用位运算，拿一个整数记录出现过的字符</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isUnique(String astr) &#123;int hash &#x3D; 0;    for(char ch: astr.toCharArray())&#123;        int index &#x3D; &#39;ch&#39; - a;        if(hash &amp; (1 &lt;&lt; index) !&#x3D; 0)&#123;            return false;        &#125;else hash |&#x3D; (1 &lt;&lt; index);    &#125;    return true;&#125;&#x2F;** 问题： 如果字符包括大小写，int是32位的，就会存不下，如果字符的范围扩大到ASCII表，该方法就无法使用了**&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><ol><li>Java中String类型是引用类型，不能像Char数组那样直接用下标去取出对应的字符。</li><li>String类型的两个常用方法： <code>char[ ] toCharyArray()</code> ，String对象调用该方法后，返回一个字符数组。  <code>char charAt(int index)</code> ，String对象调用该方法后，返回对应下标的字符。</li></ol><h3 id="判断是否互为字符重排"><a href="#判断是否互为字符重排" class="headerlink" title="判断是否互为字符重排"></a>判断是否互为字符重排</h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p><p>说明：</p><ul><li>0 &lt;&#x3D; len(s1) &lt;&#x3D; 100</li><li>0 &lt;&#x3D; len(s2) &lt;&#x3D; 100</li></ul><ol><li>对两个字符串进行排序后一个一个进行比对</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">    public boolean CheckPermutation(String s1, String s2) &#123;        if(s1.length() !&#x3D; s2.length()) return false;        char[] chars1 &#x3D; s1.toCharArray();        char[] chars2 &#x3D; s2.toCharArray();        Arrays.sort(chars1);        Arrays.sort(chars2);        for(int i &#x3D; 0; i&lt; s1.length(); i++)&#123;            if(chars1[i] !&#x3D; chars2[i]) return false;        &#125;        return  true;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可以不用排序，直接使用<code>Arrays.equals(s1,s2)</code>判断两个字符数组是否相等</strong></p><hr><ol start="2"><li>用Ascii码来比较，当两个字符串长度相等，所有字符的ASCII码相等，那么两个字符串就互为字符重排</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public boolean CheckPermutation(String s1, String s2) &#123;        int sum1 &#x3D; 0;        int sum2 &#x3D; 0;        if(s1.length() !&#x3D; s2.length()) return false;        else&#123;            for(int i&#x3D;0; i&lt;s1.length(); i++)&#123;                sum1 +&#x3D; s1.charAt(i);                sum2 +&#x3D; s2.charAt(i);            &#125;        &#125;        return (sum1 &#x3D;&#x3D; sum2);     &#125;&#x2F;**如果出现 ac 和 bb那么两个字符数组的Ascii值是一样，但是不是互为字符重排。所以该方法不对**&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h4><ul><li>Arrays工具类的使用</li></ul><h3 id="URL化"><a href="#URL化" class="headerlink" title="URL化"></a>URL化</h3><p>URL化。编写一种方法，将字符串中的空格全部替换为<code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用<code>Java</code>实现的话，请使用字符数组实现，以便直接在数组上操作。）</p><p>提示：</p><ul><li>字符串长度在[0,500000]范围内。</li></ul><p>一、遍历字符串，遇到空格替换成”%20”</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    public String replaceSpaces(String S, int length) &#123;        StringBuffer sb &#x3D; new StringBuffer();        for(int i&#x3D;0; i&lt;length; i++)&#123;            if(S.charAt(i) &#x3D;&#x3D; &#39; &#39;)&#123;                sb.append(&quot;%20&quot;);            &#125;else&#123;                sb.append(S.charAt(i));            &#125;        &#125;        return sb.toString();    &#125;这里不能用String类型去存储新的字符串，因为String类型是无法改变的，每次改变字符串就是创建一个新的字符串，会花费很多的时间。如果需要对字符串进行多次修改，需要使用StringBuffer&amp;StringBuilder类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>Tips:</p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度</p><p>解答：</p><ol><li>双重循环暴力解答</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int i &#x3D; 0; i &lt; nums.length - 1; i++)&#123;    for(int j &#x3D; i+1; j &lt; nums.length; j++)&#123;        if(nums[j] + nums[i] &#x3D;&#x3D; target)             return new int[]&#123;i,j&#125;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>HashMap，或者ArrayList也可以</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;&gt;();for(int i &#x3D; 0;i &lt;nums.length ; i++)&#123;    &#x2F;&#x2F; 如果nums[i] 在map中，表示这个nums[i]和前面一个（map.get(nums[i])）的和就是target,返回两者下标即可    if(map.containsKey(nums[i]))&#123;        return  new int[]&#123;i,map.get(nums[i])&#125;;    &#125;    &#x2F;&#x2F; map中存放的是nums[i]对应的需要找的另一个数,value是下标,key是数    map.put(target-nums[i],i);&#125;return null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p> Tips:</p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><ol><li>暴力搜索，维护一个公共前缀字符串，遍历所有字符串</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String longestCommonPrefix(String[] strs) &#123;    String pre &#x3D; &quot;&quot;;    int i &#x3D; 0;    if(strs.length &#x3D;&#x3D; 0) return pre;    pre &#x3D; strs[0];    for(String str : strs)&#123;        if(pre &#x3D;&#x3D; null) return pre;        else&#123;            i &#x3D; 0;            for(char ch: pre.toCharArray())&#123;                if(i &lt; str.length()  &amp;&amp; str.charAt(i) &#x3D;&#x3D; ch)&#123;                    i++;continue;                &#125;else&#123;                    pre &#x3D; pre.substring(0,i);  break;                &#125;            &#125;        &#125;    &#125;    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ol start="2"><li>把字符数组里面的所有字符串通过字典序规则排序，然后找出首尾字符串的最长公共前缀，就是字符串数组的最长公共前缀，但是时间复杂度和第一个方法其实是一样的。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String longestCommonPrefix(String[] strs) &#123;    String pre &#x3D; &quot;&quot;;    int i &#x3D; 0, len &#x3D; strs.length - 1;    if(strs.length &#x3D;&#x3D; 0) return pre; pre &#x3D; strs[0];    Arrays.sort(strs);    while(i &lt; strs[0].length()            &amp;&amp; i &lt; strs[len].length()            &amp;&amp; strs[0].charAt(i) &#x3D;&#x3D; strs[len].charAt(i)) i++;    pre &#x3D; strs[0].substring(0,i);    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>Tips：</p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">链表结点的结构    public class ListNode &#123;    int val;    ListNode next;    ListNode() &#123;    &#125;    ListNode(int val) &#123;        this.val &#x3D; val;    &#125;    ListNode(int val, ListNode next) &#123;        this.val &#x3D; val;        this.next &#x3D; next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ol><li>通过构造一个新的链表去存放两个链表的结点</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode head &#x3D; new ListNode();    ListNode temp &#x3D; head;    while(list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null)&#123;        if(list1.val &lt; list2.val)&#123;            temp.next &#x3D; list1;            temp &#x3D; temp.next;            list1 &#x3D; list1.next;        &#125;else&#123;            temp.next &#x3D; list2;            temp &#x3D; temp.next;            list2 &#x3D; list2.next;        &#125;    &#125;    if(list1 &#x3D;&#x3D; null) temp.next &#x3D; list2;    else temp.next &#x3D; list1;    return head.next; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大字数和"><a href="#最大字数和" class="headerlink" title="最大字数和"></a>最大字数和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><p>Tips:</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><ol><li>动态规划</li></ol><p>假设 \textit{nums}<em>nums</em> 数组的长度是 n<em>n</em>，下标从 00 到 n-1<em>n</em>−1。</p><p>我们用 f(i)<em>f</em>(<em>i</em>) 代表以第 i<em>i</em> 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：</p><p>\max_{0 \leq i \leq n-1} { f(i) }0≤<em>i</em>≤<em>n</em>−1max{<em>f</em>(<em>i</em>)}</p><p>因此我们只需要求出每个位置的 f(i)<em>f</em>(<em>i</em>)，然后返回 f<em>f</em> 数组中的最大值即可。那么我们如何求 f(i)<em>f</em>(<em>i</em>) 呢？我们可以考虑 \textit{nums}[i]<em>nums</em>[<em>i</em>] 单独成为一段还是加入 f(i-1)<em>f</em>(<em>i</em>−1) 对应的那一段，这取决于 \textit{nums}[i]<em>nums</em>[<em>i</em>] 和 f(i-1) + \textit{nums}[i]<em>f</em>(<em>i</em>−1)+<em>nums</em>[<em>i</em>] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：</p><p>f(i) &#x3D; \max { f(i-1) + \textit{nums}[i], \textit{nums}[i] }<em>f</em>(<em>i</em>)&#x3D;max{<em>f</em>(<em>i</em>−1)+<em>nums</em>[<em>i</em>],<em>nums</em>[<em>i</em>]}</p><p>不难给出一个时间复杂度 O(n)<em>O</em>(<em>n</em>)、空间复杂度 O(n)<em>O</em>(<em>n</em>) 的实现，即用一个 f<em>f</em> 数组来保存 f(i)<em>f</em>(<em>i</em>) 的值，用一个循环求出所有 f(i)<em>f</em>(<em>i</em>)。考虑到 f(i)<em>f</em>(<em>i</em>) 只和 f(i-1)<em>f</em>(<em>i</em>−1) 相关，于是我们可以只用一个变量 \textit{pre}<em>pre</em> 来维护对于当前 f(i)<em>f</em>(<em>i</em>) 的 f(i-1)<em>f</em>(<em>i</em>−1) 的值是多少，从而让空间复杂度降低到 O(1)<em>O</em>(1)，这有点类似「滚动数组」的思想。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int pre &#x3D; 0, maxAns &#x3D; nums[0];        for (int x : nums) &#123;            pre &#x3D; Math.max(pre + x, x);            maxAns &#x3D; Math.max(maxAns, pre);        &#125;        return maxAns;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h3><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。<strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p>Tips：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><ol><li>通过Java中字符串带的分割字符串方法，把字符串分割后直接返回最后一个单词的长度。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">static int lengthOfLastWord(String s) &#123;    String[] strs &#x3D; s.split(&quot;\\s+&quot;);   &#x2F;&#x2F;该正则是一个或多个空格，去掉+号就是只有一个空格间隔的分开    return strs[strs.length-1].length();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样能够得到所有的单词字符串数组，但是耗时和耗费空间</p><hr><ol start="2"><li>通过反向遍历字符串，直到遇到第一个字母，之后再遇到一个空格就返回读取到的字母数量</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">static int lengthOfLastWord(String s) &#123;    char[] chars &#x3D; s.toCharArray();    int len &#x3D; 0;    for(int i &#x3D; s.length() - 1; i &gt;&#x3D; 0 ; i--)&#123;        if(chars[i] &#x3D;&#x3D; &#39; &#39;)&#123;            if(len &#x3D;&#x3D; 0) continue;            else break;        &#125;        else len++;    &#125;    return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>‘ ‘单引号中的是字符，” “双引号中的是字符串，字符比较用 &#x3D;&#x3D; ，字符串比较用 .equals()</p><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>Tips：</p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><ol><li>只需要对数组 \textit{digits}<em>digits</em> 进行一次逆序遍历，找出第一个不为 99 的元素，将其加一并将后续所有元素置零即可。如果 digits中所有的元素均为 99，那么对应着「思路」部分的第三种情况，我们需要返回一个新的数组。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] plusOne(int[] digits) &#123;    int n &#x3D; digits.length;    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i) &#123;        if (digits[i] !&#x3D; 9) &#123;            ++digits[i];            for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;                digits[j] &#x3D; 0;            &#125;            return digits;        &#125;    &#125;    &#x2F;&#x2F; digits 中所有的元素均为 9    int[] ans &#x3D; new int[n + 1];    ans[0] &#x3D; 1;    return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="X的平方根"><a href="#X的平方根" class="headerlink" title="X的平方根"></a>X的平方根</h3><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code>。</p><p>Tips：</p><ul><li>0 &lt;&#x3D; x &lt;&#x3D; 2^31^ - 1</li></ul><ol><li>由于只需要求出整数部分，所以可以不用真的计算算数平方根，只需要求出一个数Y（Y*Y &lt;&#x3D; X   而（Y+1）x（Y+1）&gt; X 即可） 。但是数据范围比较大，如果从0开始计算，循环次数较多，耗时较大，也容易溢出，所以比较X&#x2F;m 与 m 的大小，当相差不超过1的时候，可以认为m就是X算术平方根的整数部分。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int mySqrt(int x) &#123;    if(x &lt;&#x3D; 1) return x;    int left &#x3D; 0, right &#x3D; x;    while(right - left &gt; 1)&#123;        int mid &#x3D; (left + right) &#x2F; 2;        if(x &#x2F; mid &lt; mid) right &#x3D; mid;        else left &#x3D; mid;     &#125;    return left;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><ol><li>使用Java中的Stack类，该类实现了标准的堆栈，先进后出，该题我们使用两个栈，一个用来执行push操作(in_Stack，一个用来执行pop操作（out_Stack。                         优化：Java中的Stack操作花费比较大，效率低下。使用ArrayDeque双端队列，效率会快很多，但是该类不是线程安全，很多方法也容易报错，使用时需要注意</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">class CQueue &#123;    ArrayDeque&lt;Integer&gt; stack_push;    ArrayDeque&lt;Integer&gt;  stack_pop;    public CQueue() &#123;        stack_push &#x3D; new ArrayDeque&lt;&gt;();        stack_pop &#x3D; new ArrayDeque&lt;&gt;();    &#125;    public void appendTail(int value) &#123;        stack_push.push(value);    &#125;    public int deleteHead() &#123;        if(stack_pop.isEmpty())&#123;            if(stack_push.isEmpty()) return -1;            else&#123;                while (!stack_push.isEmpty())&#123;                    stack_pop.push(stack_push.pop());                &#125;            &#125;        &#125;        return  stack_pop.pop();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="包含main函数的栈"><a href="#包含main函数的栈" class="headerlink" title="包含main函数的栈"></a>包含main函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>Tips:</p><ul><li>各函数的调用总次数不超过 20000 次</li></ul><ol><li>使用堆栈存储最小值，其他的可以直接使用堆栈</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MinStack &#123;    Stack&lt;Integer&gt; A, B;    public MinStack() &#123;        A &#x3D; new Stack&lt;&gt;();        B &#x3D; new Stack&lt;&gt;();    &#125;    public void push(int x) &#123;        A.add(x);        if(B.empty() || B.peek() &gt;&#x3D; x)            B.add(x);    &#125;    public void pop() &#123;        if(A.pop().equals(B.peek()))            B.pop();    &#125;    public int top() &#123;        return A.peek();    &#125;    public int min() &#123;        return B.peek();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p> Tips:</p><ul><li>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</li></ul><ol><li>使用一个List或者栈来存储从链表中读取的数据，然后再创建一个数组进行存储。使用栈来辅助可以不用考虑数组反转的问题，使用List可以使用Collections.reverse(List) 来使List反转，再存储到数组中。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        List&lt;Integer&gt; nodeVal &#x3D; new ArrayList&lt;&gt;();        while(head !&#x3D; null)&#123;            nodeVal.add(head.val);            head &#x3D; head.next;        &#125;        Collections.reverse(nodeVal);        int[] vals &#x3D; new int[nodeVal.size()];        int i &#x3D; 0;        for(Integer num : nodeVal)            vals[i++] &#x3D; num;        return vals;    &#125;&#125;class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        Stack&lt;ListNode&gt; stack &#x3D; new Stack&lt;ListNode&gt;();        ListNode temp &#x3D; head;        while (temp !&#x3D; null) &#123;            stack.push(temp);            temp &#x3D; temp.next;        &#125;        int size &#x3D; stack.size();        int[] print &#x3D; new int[size];        for (int i &#x3D; 0; i &lt; size; i++) &#123;            print[i] &#x3D; stack.pop().val;        &#125;        return print;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>Tips：</p><ul><li>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</li></ul><ol><li>在遍历链表时，将当前节点的next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode prev &#x3D; null;        ListNode curr &#x3D; head;        while (curr !&#x3D; null) &#123;            ListNode next &#x3D; curr.next;            curr.next &#x3D; prev;            prev &#x3D; curr;            curr &#x3D; next;        &#125;        return prev;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>递归</li></ol><p><img src="C:/Users/yty/AppData/Roaming/Typora/typora-user-images/image-20220330202603240.png" alt="递归"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;            return head;        &#125;        ListNode newHead &#x3D; reverseList(head.next);        head.next.next &#x3D; head;        head.next &#x3D; null;        return newHead;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型</title>
      <link href="/2022/03/03/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/03/03/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java的两大数据类型</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><h4 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h4><ul><li>该数据类型是8位的、有符号的，以二进制补码表示的整数；</li><li>最小值是-128（-2^7^）、最大值是127（2^7^-1)、默认值是0；</li><li>用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>Byte</li></ul><h4 id="short"><a href="#short" class="headerlink" title="short"></a>short</h4><ul><li>该数据类型是16位、有符号的，以二进制补码表示的整数;</li><li>最小值是 -32768（-2^15^) 、最大值是 32767（2^15^ - 1)、默认值是0；</li><li>short变量是int型变量所占空间的二分之一；</li><li>Short</li></ul><h4 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h4><ul><li>int数据类型是32位，有符号的，以二进制补码表示的整数；</li><li>最小值是 -2^31^ 、最大值是 2^31^ - 1、默认值是0；</li><li>一般的整型变量默认是int类型；</li><li>Integer</li></ul><h4 id="long"><a href="#long" class="headerlink" title="long"></a>long</h4><ul><li>long数据类型是64位、有符号的，以二进制补码表示的整数；</li><li>最小值-2^63^、最大值2^63^-1，默认值是0L；</li><li>使用long型最好在数据结尾加上L，可以使用小写l。但是l容易与数字1混淆；</li><li>Long</li></ul><h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><ul><li>该数据类型是单精度、32位、符合IEEE754标准的浮点数；</li><li>默认值是0.0f；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>Float</li></ul><h4 id="double"><a href="#double" class="headerlink" title="double"></a>double</h4><ul><li>双精度、64位、符合IEEE754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>默认值是0.0d；</li><li>Double</li></ul><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><ul><li>数据类型表示一位的信息；</li><li>只有两个取值，true和false；</li><li>默认值是false；</li></ul><h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><ul><li>是一个单一的16位Unicode字符；</li><li>char类型可以存储任何字符；</li><li>Character</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>在Java中，引用类型的变量非常类似于C&#x2F;C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p><ul><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Java中使用final关键字来修饰常量，声明方式和变量类似。</p><blockquote><p>final double Pi &#x3D; 3.1415926535;</p></blockquote><p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。</p><p>字符串常量和字符常量都可以包含任何Unicode字符。</p><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级</p><blockquote><p>低————————————————————–&gt;高</p><p>byte、short、char-&gt; int -&gt; long -&gt; float -&gt; double</p></blockquote><p>数据类型转换必须满足如下规则：</p><ol><li><p>不能对boolean类型进行类型转换。</p></li><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度。</p></li></ol><h4 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ol><li>条件是转换的数据类型必须是兼容的。</li><li>(type) value type是要强制类型转换后的数据类型。</li></ol><h4 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h4><ol><li>整数的默认类型都是int。</li><li>浮点型不存在这种情况，因为定义在float类型时必须在数字后面跟上F或者f。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法规范</title>
      <link href="/2022/03/03/Java%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/"/>
      <url>/2022/03/03/Java%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li><strong>大小写敏感</strong>：标识符Hello和hello是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如：FirstDemo。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，应该使用类名作为文件名保存，文件名的后缀是.java。</li><li>主方法入口：所有的Java程序由 public static void mian(String args[])方法开始执行。</li></ol><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p><strong>Java所有的组成部分都需要名字。类名、变量名、以及方法名都被称为标识符。</strong></p><ul><li>所有的标识符都应该以**字母、$、_ **  开头</li><li>首字符之后可以是<strong>字母、$、_ 、或数字</strong>的任何组合</li><li><a href="#q1">关键字</a>不能用做标识符</li><li>标识符是大小写敏感的</li></ul><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>Java可以用修饰符来修饰类中的方法和属性。主要由两类修饰符：</p><ul><li>访问控制修饰符：default、public、protected、private</li><li>非访问控制修饰符：final、abstract、static、synchronized</li></ul><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p><p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><a id="q1"></a></p><p>这些关键字不能用于常量、变量、和任何标识符的名称。</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">类别</td><td align="center">关键字</td><td align="center">说明</td></tr><tr><td align="center">访问控制</td><td align="center">private</td><td align="center">私有的</td></tr><tr><td align="center">protected</td><td align="center">受保护的</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">公共的</td><td align="center"></td></tr><tr><td align="center">类、方法和变量修饰符</td><td align="center">abstract</td><td align="center">声明抽象</td></tr><tr><td align="center">class</td><td align="center">类</td><td align="center"></td></tr><tr><td align="center">extends</td><td align="center">扩充,继承</td><td align="center"></td></tr><tr><td align="center">final</td><td align="center">最终值,不可改变的</td><td align="center"></td></tr><tr><td align="center">implements</td><td align="center">实现（接口）</td><td align="center"></td></tr><tr><td align="center">interface</td><td align="center">接口</td><td align="center"></td></tr><tr><td align="center">native</td><td align="center">本地，原生方法（非 Java 实现）</td><td align="center"></td></tr><tr><td align="center">new</td><td align="center">新,创建</td><td align="center"></td></tr><tr><td align="center">static</td><td align="center">静态</td><td align="center"></td></tr><tr><td align="center">strictfp</td><td align="center">严格,精准</td><td align="center"></td></tr><tr><td align="center">synchronized</td><td align="center">线程,同步</td><td align="center"></td></tr><tr><td align="center">transient</td><td align="center">短暂</td><td align="center"></td></tr><tr><td align="center">volatile</td><td align="center">易失</td><td align="center"></td></tr><tr><td align="center">程序控制语句</td><td align="center">break</td><td align="center">跳出循环</td></tr><tr><td align="center">case</td><td align="center">定义一个值以供 switch 选择</td><td align="center"></td></tr><tr><td align="center">continue</td><td align="center">继续</td><td align="center"></td></tr><tr><td align="center">default</td><td align="center">默认</td><td align="center"></td></tr><tr><td align="center">do</td><td align="center">运行</td><td align="center"></td></tr><tr><td align="center">else</td><td align="center">否则</td><td align="center"></td></tr><tr><td align="center">for</td><td align="center">循环</td><td align="center"></td></tr><tr><td align="center">if</td><td align="center">如果</td><td align="center"></td></tr><tr><td align="center">instanceof</td><td align="center">实例</td><td align="center"></td></tr><tr><td align="center">return</td><td align="center">返回</td><td align="center"></td></tr><tr><td align="center">switch</td><td align="center">根据值选择执行</td><td align="center"></td></tr><tr><td align="center">while</td><td align="center">循环</td><td align="center"></td></tr><tr><td align="center">错误处理</td><td align="center">assert</td><td align="center">断言表达式是否为真</td></tr><tr><td align="center">catch</td><td align="center">捕捉异常</td><td align="center"></td></tr><tr><td align="center">finally</td><td align="center">有没有异常都执行</td><td align="center"></td></tr><tr><td align="center">throw</td><td align="center">抛出一个异常对象</td><td align="center"></td></tr><tr><td align="center">throws</td><td align="center">声明一个异常可能被抛出</td><td align="center"></td></tr><tr><td align="center">try</td><td align="center">捕获异常</td><td align="center"></td></tr><tr><td align="center">包相关</td><td align="center">import</td><td align="center">引入</td></tr><tr><td align="center">package</td><td align="center">包</td><td align="center"></td></tr><tr><td align="center">基本类型</td><td align="center">boolean</td><td align="center">布尔型</td></tr><tr><td align="center">byte</td><td align="center">字节型</td><td align="center"></td></tr><tr><td align="center">char</td><td align="center">字符型</td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">双精度浮点</td><td align="center"></td></tr><tr><td align="center">float</td><td align="center">单精度浮点</td><td align="center"></td></tr><tr><td align="center">int</td><td align="center">整型</td><td align="center"></td></tr><tr><td align="center">long</td><td align="center">长整型</td><td align="center"></td></tr><tr><td align="center">short</td><td align="center">短整型</td><td align="center"></td></tr><tr><td align="center">变量引用</td><td align="center">super</td><td align="center">父类,超类</td></tr><tr><td align="center">this</td><td align="center">本类</td><td align="center"></td></tr><tr><td align="center">void</td><td align="center">无返回值</td><td align="center"></td></tr><tr><td align="center">保留关键字</td><td align="center">goto</td><td align="center">是关键字，但不能使用</td></tr><tr><td align="center">const</td><td align="center">是关键字，但不能使用</td><td align="center"></td></tr><tr><td align="center">null</td><td align="center">空</td><td align="center"></td></tr></tbody></table><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p><p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><h4 id="源程序与编译型运行区别"><a href="#源程序与编译型运行区别" class="headerlink" title="源程序与编译型运行区别"></a>源程序与编译型运行区别</h4><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/java1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>糖醋排骨</title>
      <link href="/2022/03/02/%E7%B3%96%E9%86%8B%E6%8E%92%E9%AA%A8/"/>
      <url>/2022/03/02/%E7%B3%96%E9%86%8B%E6%8E%92%E9%AA%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/food1.jpg" alt="糖醋排骨"></p><p>糖醋汁：料酒一勺、生抽一勺、老抽半勺、醋三勺、白糖半勺</p><ol><li><p>调个酱汁：料酒1勺+生抽1勺+老抽半勺+醋3勺+白糖半勺</p></li><li><p>排骨冷水下锅，放入葱姜料酒焯水，煮出血沫后捞出控干水分 </p></li><li><p>锅里少许油倒入排骨，煎至表皮金黄盛出，再放15颗冰糖炒至融化，倒入排骨翻拌均匀裹上糖色～</p></li><li><p>加水没过排骨，倒入料汁，中火闷煮30分钟后大火收汁，撒上芝麻即可～</p></li></ol><p><strong>收汁的时候，差不多了再淋上一圈醋</strong> (防止粘锅，烧焦，口感会好一些，不会很柴)</p>]]></content>
      
      
      <categories>
          
          <category> 食谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 糖醋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Matery 搭建遇到的搜索不到的小问题</title>
      <link href="/2022/03/02/Hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/03/02/Hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    花费了几天时间用Hexo搭建了自己的博客，准备用来存放一些学习笔记、心得之类的 。然后使用了Matery主题美化，途中真的遇到了很多很多问题，有一些现在也没找到解决办法，暂时就存在这里。</p><p>遇到Bug会经常更新。</p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><h5 id="首页展示图"><a href="#首页展示图" class="headerlink" title="首页展示图"></a>首页展示图</h5><p>​    这个地方展示图片我试验了一下，好像有自适应大小，不用担心图片显示出现异常。比如说图片被拉伸什么，不过得考虑大小（<strong>指的是所占内存大小</strong>）吧。如果图片过大，你加载出来会非常的慢，如果你是部署到GitHub上，那就会遇到加载很久的情况。可以考虑做一个双部署，部署到GitHub上的同时也部署到Gitee（码云）上，访问速度会好很多。</p><h5 id="Pic-Go-Gitee图床"><a href="#Pic-Go-Gitee图床" class="headerlink" title="Pic Go+Gitee图床"></a>Pic Go+Gitee图床</h5><h6 id="图床上的图片显示不了"><a href="#图床上的图片显示不了" class="headerlink" title="图床上的图片显示不了"></a>图床上的图片显示不了</h6><p>​    我是按照网上搜索的教程搭建的一个图床，使用Gitee存储图片。遇到过上传的图片无法在博客里正常显示问题，去Pic Go查看图片也是无法显示图片。去网上搜索了很多，可能的原因是：</p><ol><li>路径出错了，你在md文档里引用的路径有问题。</li><li>图片格式问题。我目前正常显示的图片是.jpg格式、.png格式，还有其他格式还没有试过。上传的时候注意一下格式。</li><li>图片大小问题，如果图片过大，也是无法显示的。我目前能显示的最大的图片是3M左右。无法显示的图片在PicGo里的相册也是无法显示的，如下：</li></ol><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/hexo1.jpg" alt="图片显示异常"></p><ol start="4"><li>gitee仓库容量有限制，注意自己剩余的存储空间。</li></ol><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/hexo2.jpg" alt="gitee仓库配额"></p><h6 id="图床存储博客所有图片"><a href="#图床存储博客所有图片" class="headerlink" title="图床存储博客所有图片"></a>图床存储博客所有图片</h6><p>​    我目前使用图床能存储博客中拆入的图片、博客的特色图片、背景图。</p><p>博客的特色图片，使用的图床存储的时候，注意引用格式**img:  “一定要用双引号，还有 【:】后面有一个空格” **不然就会导致图片显示失败。</p><p>背景图，不是首页的展示图（banner）。是主题的配置文件里面的background。更换背景图片的时候，注意图片尺寸，这里的显示并没有自适应，你必须使用相对应的尺寸，不然图片会被拉长。Matery主题背景图的尺寸是2K(2560*1440)。</p><p>可以去网上去找一个在线修改图片尺寸和大小的网站，很方便，可以把自己喜欢的图片修改成适合的大小和尺寸然后就可以放在自己的博客上了。</p><p>找不到的话我这里放一个我搜到的，能用的，每天免费修改20次，每个浏览器单独计算次数（不登录的话）。<a href="https://www.gaitubao.com/">改图宝 - 在线修改照片大小尺寸工具 (gaitubao.com)</a></p><h4 id="图标（待做）"><a href="#图标（待做）" class="headerlink" title="图标（待做）"></a>图标（待做）</h4><p>我尝试把自己的图片替换主题文件里面的网站图片与logo，但是都无法正常显示。等我能正常更换了再来更新。</p><h4 id="RSS订阅"><a href="#RSS订阅" class="headerlink" title="RSS订阅"></a>RSS订阅</h4><p>这个功能不知道有什么问题，我按照主题的教程，一步一步开启RSS订阅，但是点击之后打开了一个新的页面（显示了一堆源码），功能无法正常使用。</p><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/hexo3.png" alt="RSS订阅"></p><h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p>Prism.languages.typescript.keyword.push is not a function</p><p>报错显示了一堆node_modules里面的Jscript文件信息</p><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/TypeError.png" alt="报错信息"></p><p>多次控制变量后找出了问题所在，就是我在我的新博客里面使用了<strong>yaml代码块</strong>导致的，具体愿意不清楚，只要不使用<strong>yaml代码块</strong>就没有问题。</p><p>但是使用yml又没有问题。</p><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/yml.png" alt=".yml代码块"></p><p><img src="https://gitee.com/Lycheecutest/imgs/raw/master/blog/yaml.png" alt=".yaml代码块"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Matery主题美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thymeleaf</title>
      <link href="/2022/03/01/thymeleaf/"/>
      <url>/2022/03/01/thymeleaf/</url>
      
        <content type="html"><![CDATA[<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="1-1-标准变量表达式"><a href="#1-1-标准变量表达式" class="headerlink" title="1.1 标准变量表达式"></a>1.1 标准变量表达式</h4><ul><li>语法：**${…}**</li><li>说明：Thymeleaf 中的变量表达式使用 {变量名} 的方式获取 Controller 中 model 其中的数据</li><li>th:text &#x3D; “${变量名}”</li></ul><hr><h4 id="1-2-访问Request作用域中的值"><a href="#1-2-访问Request作用域中的值" class="headerlink" title="1.2 访问Request作用域中的值"></a>1.2 访问Request作用域中的值</h4><ul><li>假设request作用域中存在键值对：**”key”&#x3D;value**可以使用标准变量表达式</li><li>语法：**${Key}**</li><li>注意：<ul><li>因为Model中的值本质上是在request作用域中存储的，所以两者的取值方法可以混用</li><li>有些标准变量表达式在IDEA中可能会报错，但是在运行时依旧可以取到值</li></ul></li></ul><hr><h4 id="1-3-访问Session会话作用域中的值"><a href="#1-3-访问Session会话作用域中的值" class="headerlink" title="1.3  访问Session会话作用域中的值"></a>1.3  访问Session会话作用域中的值</h4><ul><li>假设Session作用域中存在键值对：**”key”&#x3D;value**可以使用标准变量表达式</li><li>语法：**${session.key}**</li></ul><hr><h4 id="1-4-访问Application全局作用域中的值"><a href="#1-4-访问Application全局作用域中的值" class="headerlink" title="1.4 访问Application全局作用域中的值"></a>1.4 访问Application全局作用域中的值</h4><ul><li>假设Application作用域中存在键值对：**”key”&#x3D;value**可以使用标准变量表达式</li><li>语法：**${application.key}**</li></ul><hr><h4 id="1-5空值处理"><a href="#1-5空值处理" class="headerlink" title="1.5空值处理"></a>1.5空值处理</h4><ul><li>语法：**${对象名？.属性名}**</li><li>如果一个对象<strong>可能</strong>为 null 时，并且要<strong>获取该对象的属性</strong>时，这时需要在该对象后面加一个”<code>?</code>“，当一个为 null 的对象去获取一个属性时，会报<code>TemplateInputException</code>（模板输入&#x2F;解析异常）</li></ul><hr><h4 id="2-1-选择变量表达式"><a href="#2-1-选择变量表达式" class="headerlink" title="2.1 选择变量表达式"></a>2.1 选择变量表达式</h4><ul><li><p>语法：**${…}**</p></li><li><p>说明：选择变量表达式，也叫星号变量表达式，使用 <code>th:object</code> 属性来绑定对象；也可以不使用 <code>th:object</code> 属性来绑定对象，则使用方法与${}相同</p></li><li><p>使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>object</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;user&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    用户编号：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>*&#123;id&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>    用户姓名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>*&#123;name&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="2-2-URL表达式"><a href="#2-2-URL表达式" class="headerlink" title="2.2 URL表达式"></a>2.2 URL表达式</h4><ul><li><p>语法：**@{….}**</p></li><li><p>说明：主要用于链接、地址的展示， 可用于<code>&lt;script src=&quot;...&quot;&gt;</code>、 <code>&lt;link href=&quot;...&quot;&gt;</code>、 <code>&lt;a href=&quot;...&quot;&gt;</code>、 <code>&lt;form action=&quot;...&quot;&gt;</code>、 <code>&lt;img src=&quot;&quot;&gt;</code>等，可以在 URL 路径中动态获取数据</p></li><li><p>使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>绝对路径<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@&#123;http://localhost:8080/thymeleaf/info&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>绝对路径<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@&#123;<span class="token punctuation">'</span>http://localhost:8080/thymeleaf/user/info?id=<span class="token punctuation">'</span>+$&#123;user.id&#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>绝对路径(带参数)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>相对路径，常用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@&#123;/thymeleaf/info&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>相对路径<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@&#123;<span class="token punctuation">'</span>/thymeleaf/user/info?id=<span class="token punctuation">'</span> + $&#123;user.id&#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>相对路径（带参数）（字符串拼接） <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@&#123;/thymeleaf/info(id=$&#123;user.id&#125;, name=$&#123;user.name&#125;)&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>推荐：带多个参数路径写法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><h4 id="1-th-action"><a href="#1-th-action" class="headerlink" title="1. th:action"></a>1. th:action</h4><ul><li><code>th:action</code>：定义后台控制器的路径，类似<code>&lt;form&gt;</code>标签的 action 属性，主要结合 URL 表达式,获取动态变量</li></ul><h4 id="2-th-method"><a href="#2-th-method" class="headerlink" title="2.th:method"></a>2.th:method</h4><ul><li>设置请求方法</li></ul><hr><h4 id="3-th-href"><a href="#3-th-href" class="headerlink" title="3. th:href"></a>3. th:href</h4><ul><li>定义超链接， 主要结合 URL 表达式,获取动态变量</li></ul><hr><h4 id="4-th-src"><a href="#4-th-src" class="headerlink" title="4. th:src"></a>4. th:src</h4><ul><li><p>用于外部资源引入，比如<code>&lt;script&gt;</code>标签的 src 属性， <code>&lt;img&gt;</code>标签的 src 属性，常与@{}表达式结合使用。</p><p>SpringBoot 项目的静态资源都放到 resources 的 static 目录下。放到 static 路径下的内容，写路径时不需要写上 static。</p></li><li><p>&#96;&#96;&#96;html</p><!--以下方式无法引入 js--><script src="/static/js/jquery-1.7.2.min.js"></script><!--该方法是常用方法--><script type="text/javascript" th:src="@{/jquery-1.7.2.min.js}"></script><pre class="line-numbers language-none"><code class="language-none">---#### 5. th:id&#x2F;name&#x2F;value- 替换 html 标签中的 id，name，value 属性---#### 6. th:attr- 该属性也是用于给 HTML 中某元素的某属性赋值，好处是可以给 html 中没有定义的属性动态的赋值。- 使用：  &#96;&#96;&#96;html  &lt;span zhangsan&#x3D;&quot;$&#123;user.name&#125;&quot;&gt;该方法赋值不成功&lt;&#x2F;span&gt;    &lt;!--通过 th:attr 对自定义的属性赋值--&gt;  &lt;span th:attr&#x3D;&quot;zhangsan&#x3D;$&#123;user.name&#125;&quot;&gt;可以赋值成功&lt;&#x2F;span&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="7-th-text"><a href="#7-th-text" class="headerlink" title="7. th:text"></a>7. th:text</h4><ul><li>用于文本的显示，该属性显示的文本在标签体中，即两个标签对之间。如果是表单标签，使用<code>th:value</code></li></ul><hr><h4 id="8-th-object"><a href="#8-th-object" class="headerlink" title="8. th:object"></a>8. th:object</h4><ul><li>用于数据对象绑定，通常用于选择变量表达式（星号表达式）</li></ul><hr><h4 id="9-th-onclick"><a href="#9-th-onclick" class="headerlink" title="9.  th:onclick"></a>9.  th:onclick</h4><ul><li><p>目前thymeleaf版本要求智能传递数字和布尔值</p></li><li><p>使用:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--目前 thymeleaf 版本要求只能传递数字和布尔值--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>show(<span class="token punctuation">'</span> + $&#123;user.id&#125; + <span class="token punctuation">'</span>)<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击：显示学生编号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><script type="text/javascript">      function show(id) {          alert("用户编号为： " + id);      }  </script>  <pre class="line-numbers language-none"><code class="language-none">    ---#### 10. th:inline- ---#### 11. th:fragment  &#x2F;  include  &#x2F;  replace- **th:fragment**- 用于页面指定一个通用（复用）的代码片段，例如在页面&#96;common&#x2F;view1.html&#96;中有如下定义：- &#96;&#96;&#96;html  &lt;div th:fragment&#x3D;&quot;pageHead&quot;&gt;  一些代码，比如说同一个网站每个页面的头和尾都相同，将公共的代码抽取出来写在这里  &lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li><p><strong>th:include</strong></p></li><li><p>在页面中引入 <strong>th:fragment</strong>定义的代码片段</p></li><li><p>使用格式：</p><p><strong>th:included&#x3D;”view :: selector” : “::”</strong> 前面是模板文件名，后面是选择器</p><p><strong>::selector:</strong> 只写选择器，这里指的就是<strong>fragment</strong>名称，则加载本页面对应的fragment</p><p><strong>view</strong>或者<strong>view：HTML</strong>： 只写模板文件名或者使用html标签，则加载整个页面</p></li><li><p>比如：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>included</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>common/view1::pageHead<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><ul><li><p><strong>th:replace</strong></p></li><li><p>th:replace 和 th:included 都是加载代码块内容，但是还是有所不同</p></li><li><p><strong>th:replace</strong> 替换当前标签为模板中的标签，加载的节点会整个替换掉加载它的div</p></li><li><p><strong>th:include</strong> 加载模板的内容：读取加载节点的内容【不包含节点名称】，替换div内容</p></li><li><p>比如：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- th:fragment 定义用于加载的块 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>fragment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 这是公共部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>引用时：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">include：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>include</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pagination::view<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>replace：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>replace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pagination::view<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结果如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">include：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>这是公共部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>replace：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>这是公共部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><h4 id="1-th-each"><a href="#1-th-each" class="headerlink" title="1. th:each"></a>1. th:each</h4><ul><li><p>这个属性非常常用，比如从后台传来一个对象集合，那么就可以使用此属性遍历输出，它与<strong>JSTL</strong>中的**&lt;c: forEach&gt;**类似。此属性既可以循环遍历集合，也可以循环遍历数组及Map。</p></li><li><p>语法：<strong>th:each&#x3D;”user, iterStat : ${userList}”</strong></p><p>​          <strong>th:each&#x3D;”user : ${userList}”</strong></p><ul><li>第一个参数：定义变量，接收集合中的一个元素</li><li>第二个参数：记录循环体信息，也可以不定义，则默认变量名位迭代变量名加上Stat后缀，即userStat<ul><li>index：当前迭代对象的index（从0开始）</li><li>count：当前迭代对象的个数（从1开始）</li><li>size：被迭代对象的大小</li><li>current：当前迭代变量</li><li>even&#x2F;odd：布尔值，当前循环是否是偶数&#x2F;奇数（从0开始）</li><li>first：布尔值，当前循环是否是第一个</li><li>last：布尔值，当前循环是否是最后一个</li></ul></li><li>第三个参数：后台传回来的数据</li><li>第一个参数和第二个参数用<strong>，</strong>隔开，第二个参数和第三个参数用<strong>：</strong>隔开</li></ul></li><li><p>举例：</p><pre class="line-numbers language-heml" data-language="heml"><code class="language-heml">&lt;h1&gt;遍历集合或者数组&lt;&#x2F;h1&gt;&lt;div th:each&#x3D;&quot;user,userStat:$&#123;userList&#125;&quot;&gt;&lt;span th:text&#x3D;&quot;$&#123;userStat.index&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;span th:text&#x3D;&quot;$&#123;user.id&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;span th:text&#x3D;&quot;$&#123;user.name&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;h1&gt;遍历map，每个元素就是一个键值对，通过key和value来取出键或者值&lt;&#x2F;h1&gt;&lt;tr th:each&#x3D;&quot;userMap:$&#123;userMaps&#125;&quot;&gt;    &lt;td th:text&#x3D;&quot;$&#123;userMap.key&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;userMap.value&#125;&quot;&gt;&lt;&#x2F;td&gt;    &lt;td th:text&#x3D;&quot;$&#123;userMap.value.name&#125;&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="2-th-if-x2F-th-unless"><a href="#2-th-if-x2F-th-unless" class="headerlink" title="2. th:if &#x2F; th: unless"></a>2. th:if &#x2F; th: unless</h4><ul><li><p>th:if是条件满足执行，th:unless相反，条件不满足时执行</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--sex等于1则显示男，sex等于0则显示女--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;sex eq 1&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男： <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;sex eq 0&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>女： <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="3-th-switch-x2F-th-case"><a href="#3-th-switch-x2F-th-case" class="headerlink" title="3. th:switch &#x2F; th: case"></a>3. th:switch &#x2F; th: case</h4><ul><li><p>一旦某个case判断值为true，剩余的case默认不执行。**” * “** 表示默认显示的case，前面的case都不匹配的时候，执行默认</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>th:switch/th:case 用法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>switch</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;sex&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>case</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>性别：男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>case</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>性别：女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>case</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>*<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>性别：保密<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> -前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
